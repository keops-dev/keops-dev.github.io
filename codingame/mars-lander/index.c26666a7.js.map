{"mappings":"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","sources":["src/readline.ts","node_modules/@parcel/runtime-js/lib/bundles/runtime-13ee4e547493a3c9.js","src/drawer.ts","src/config.ts","src/Game.ts","src/index.ts"],"sourcesContent":["import FICHIER_ENTREES from \"bundle-text:./entrees.txt\"\n\n// On crée le générateur pour lire le fichier\nlet reader = fileReader(FICHIER_ENTREES)\n\n// Générateur pour lire une par une les lignes du fichier des entrées\nfunction* fileReader(fichier) {\n  const lignes = fichier.split(\"\\n\")\n  for (ligne of lignes) {\n    yield ligne\n  }\n}\n\nexport default function readline() {\n  return reader.next().value\n}\n","module.exports = \"b508f6dd6f15c3b1\";","import { AREA_HEIGHT, AREA_WIDTH } from \"./config\"\nimport { Position } from \"./types\"\n\n/**\n * Get Mars Bg Canvas context\n */\nexport function getBgContext() {\n  const mars = document.getElementById(\"mars_bg\")\n  if (mars == null || !(mars instanceof HTMLCanvasElement)) {\n    throw new Error(\n      \"L'élément sélectionné n'existe pas ou n'est pas un canvas ([id='mars_bg'])\"\n    )\n  }\n  return mars.getContext(\"2d\")\n}\n\n/**\n * Get lander animation Canvas context\n */\nexport function getAnimationContext() {\n  const mars = document.getElementById(\"animation\")\n  if (mars == null || !(mars instanceof HTMLCanvasElement)) {\n    throw new Error(\n      \"L'élément sélectionné n'existe pas ou n'est pas un canvas ([id='animation'])\"\n    )\n  }\n  return mars.getContext(\"2d\")\n}\n\nexport function drawMars(surfaces: Position[]) {\n  const ctx = getBgContext()\n  if (ctx) {\n    ctx.save()\n    ctx.translate(0, AREA_HEIGHT)\n    ctx.scale(1, -1)\n    ctx.beginPath()\n    ctx.moveTo(0, 0)\n    ctx.lineTo(0, surfaces[0].y)\n    for (const surface of surfaces) {\n      ctx.lineTo(surface.x, surface.y)\n    }\n    ctx.lineTo(7000, 0)\n    ctx.fillStyle = \"rgb(146, 53, 53)\"\n    ctx.fill()\n    ctx.restore()\n  }\n}\n\nconst LANDER_HEIGHT = 200\nconst LANDER_WIDTH = 136\nconst HALF_LANDER_HEIGHT = 100\n\n/**\n * Dessine dans un Canvas le résultat du programme\n */\nexport function drawMarsLander(pos: Position, rotation: number) {\n  const ctx = getAnimationContext()\n  ctx?.save()\n  ctx?.translate(0, AREA_HEIGHT)\n  ctx?.scale(1, -1)\n  ctx!.fillStyle = \"rgb(245, 42, 76)\"\n  ctx?.fillRect(pos.x - 5, pos.y - 5, 10, 10)\n  ctx!.fillStyle = \"#fff\"\n  ctx?.fillRect(2500 - 5, 1167 - 5, 10, 10)\n  // const angleRadian = (Math.PI / 180) * rotation\n  // ctx.save()\n  // ctx.rotate(angleRadian)\n  // ctx.drawImage(lander, marsLander.x - HALF_LANDER_HEIGHT, marsLander.y)\n  // ctx.restore()\n  const mars = document.getElementById(\"mars_bg\")?.getBoundingClientRect()\n  const marsLander = document.getElementById(\"mars_lander\")\n  const x = Math.round((pos.x / AREA_WIDTH) * mars!.width)\n  const y = Math.round((pos.y / AREA_HEIGHT) * mars!.height)\n\n  marsLander!.style.transform = `translate(${x}px, ${-y}px) rotate(${-rotation}deg)`\n  ctx?.restore()\n}\n","export const AREA_WIDTH = 7000\nexport const AREA_HEIGHT = 3000\n","import { drawMars, drawMarsLander, getAnimationContext } from \"./drawer\"\nimport { Position, Vector } from \"./types\"\n\nconst REFRESH_RATE = 500\nconst gameDataUlist = document.getElementById(\"game_data\") as HTMLUListElement\nconst gameDataTime = document.getElementById(\"time_value\")\nconst gameDataAltitude = document.getElementById(\"altitude_value\")\nconst gameDataPosition = document.getElementById(\"position_value\")\nconst gameDataFuel = document.getElementById(\"fuel_value\")\nconst gameDataHorizontalSpeed = document.getElementById(\n  \"horizontal_speed_value\"\n)\nconst gameDataVerticalSpeed = document.getElementById(\"vertical_speed_value\")\n\nif (gameDataUlist == null) {\n  throw new Error(\"La div gameDataDiv n'a pas été trouvée\")\n}\n\nclass MarsLander {\n  pos: Position\n  fuel: number // the quantity of remaining fuel in liters.\n  hSpeed: number = 0 // the horizontal speed (in m/s), can be negative.\n  vSpeed: number = 0 // the vertical speed (in m/s), can be negative.\n  rotate: number = -5 // the rotation angle in degrees (-90 to 90).\n  power: number = 0 // the thrust power (0 to 4).\n  requestedPower = 3\n\n  constructor(pos: Position, fuel: number) {\n    this.pos = pos\n    this.fuel = fuel\n  }\n}\n\nexport default class Game {\n  height: number\n  width: number\n  gravity = 3.711\n  timer = 0\n\n  surfaces: Position[]\n  lander: MarsLander\n  // le sol martien est composé des points données par codingame\n  // plus {0,0} et {largeur,0}\n  ground: Position[]\n  ctx\n\n  constructor(height: number, width: number) {\n    this.height = height\n    this.width = width\n    this.doTurn = this.doTurn.bind(this)\n  }\n\n  init(surfaces: Position[], marsLander) {\n    this.surfaces = surfaces\n    this.ground = [{ x: 0, y: 0 }, ...surfaces, { x: this.width, y: 0 }]\n    this.lander = new MarsLander(marsLander.pos, marsLander.fuel)\n    // this.ctx = getAnimationContext()\n    // setInterval(this.draw, REFRESH_RATE)\n    this.drawGround()\n    this.draw()\n  }\n\n  start() {\n    // setTimeout(() => window.requestAnimationFrame(this.draw), 1000 / 24)\n    this.doTurn()\n  }\n\n  intersectSegment(\n    A: Position,\n    B: Position,\n    I: Position,\n    P: Position\n  ): Position | undefined {\n    const D: Vector = { x: 0, y: 0 }\n    const E: Vector = { x: 0, y: 0 }\n    D.x = B.x - A.x\n    D.y = B.y - A.y\n    E.x = P.x - I.x\n    E.y = P.y - I.y\n    const denom = D.x * E.y - D.y * E.x\n    if (denom === 0) {\n      return\n    }\n    const t = -(A.x * E.y - I.x * E.y - E.x * A.y + E.x * I.y) / denom\n    if (t < 0 || t >= 1) {\n      return\n    }\n    const u = -(-D.x * A.y + D.x * I.y + D.y * A.x - D.y * I.x) / denom\n    if (u < 0 || u >= 1) {\n      return\n    }\n    const x = I.x + u * E.x\n    const y = A.y + t * D.y\n    return { x, y }\n  }\n\n  collision(tab: Position[], P: Position): Position | undefined {\n    const pointsNum: number = tab.length\n    const I: Position = { x: 0, y: 0 }\n    // I.x = 10000 + (Math.random() % 100) // 10000 + un nombre aléatoire entre 0 et 99\n    I.x = P.x\n    I.y = 10000 + (Math.random() % 100)\n    const intersections: Position[] = []\n    for (let i = 0; i < pointsNum; i++) {\n      const A = tab[i]\n      let B\n      if (i == pointsNum - 1)\n        // si c'est le dernier point, on relie au premier\n        B = tab[0]\n      // sinon on relie au suivant.\n      else B = tab[i + 1]\n      const iseg = this.intersectSegment(A, B, I, P)\n      if (iseg) intersections.push(iseg)\n    }\n    if (intersections.length % 2 == 1) {\n      // nbintersections est-il impair ?\n      console.log(\"COLLISION avec pour pos\", intersections[0])\n      return intersections[0]\n    } else return\n  }\n\n  doTurn() {\n    // add a second\n    this.timer += 1\n    this.updateLander()\n\n    const collision = this.collision(this.ground, this.lander.pos)\n    if (collision) {\n      // s'il y a collision la prochaine position du lander sera le point d'impact\n      this.lander.pos = collision\n    } else {\n      setTimeout(() => window.requestAnimationFrame(this.doTurn), 1000 / 120)\n    }\n    this.draw()\n    this.updateDataUList()\n    // déclenche un crash si ce n'est pas une zone d'atterissage et si les parametres d'atterissages ne sont pas bon\n    // sinon atterit\n    // if (this.lander.pos.y > 1150) {\n    //   window.requestAnimationFrame(this.doTurn)\n    //   // setTimeout(() => window.requestAnimationFrame(this.doTurn), 1000 / 60)\n    // }\n  }\n\n  updateLander() {\n    const lander = this.lander\n    // update lander power\n    // +1 / turn\n    this.lander.power =\n      lander.power === lander.requestedPower\n        ? lander.power\n        : lander.power + (lander.requestedPower > lander.power ? +1 : -1)\n    // vitesse vertical\n    // comme on simule une chute libre, l'acceleration vertical du lander est constante\n    // donc : sa vitesse = acceleration * temps\n    const pousséeY =\n      Math.cos((this.lander.rotate * Math.PI) / 180) * this.lander.power\n    const pousséeX =\n      -Math.sin((this.lander.rotate * Math.PI) / 180) * this.lander.power\n    console.log(\"poussée\", pousséeX.toString(), pousséeY.toString())\n\n    console.log(\"test\", parseFloat(pousséeX.toFixed(3)))\n\n    // !attention : codingame arrondi ses vitesses à la 2eme decimale\n    this.lander.vSpeed += parseFloat((-this.gravity + pousséeY).toFixed(3))\n    this.lander.hSpeed += parseFloat(pousséeX.toFixed(3))\n    // gravitée\n    // this.lander.pos.x += this.lander.hSpeed\n    this.lander.pos.x += this.lander.hSpeed\n    this.lander.pos.y += this.lander.vSpeed\n    console.log(JSON.stringify(this.lander))\n  }\n\n  updateDataUList() {\n    gameDataTime!.textContent = this.timer.toString()\n    gameDataAltitude!.textContent = this.lander.pos.y.toString()\n    gameDataPosition!.textContent = this.lander.pos.x.toString()\n    gameDataFuel!.textContent = this.lander.fuel.toString()\n    gameDataHorizontalSpeed!.textContent = this.lander.hSpeed.toString()\n    gameDataVerticalSpeed!.textContent = this.lander.vSpeed.toString()\n  }\n\n  drawGround() {\n    drawMars(this.surfaces)\n  }\n\n  draw() {\n    drawMarsLander(this.lander.pos, this.lander.rotate)\n  }\n\n  /**\n   * Retourne les nouvelles données du Mars Lander après l'execution d'un tour\n   * comme le ferait l'ide de Codingame dans son \"game loop\"\n   */\n  playTurn() {}\n}\n","import readline from \"./readline\"\nimport Game from \"./Game\"\nimport { AREA_HEIGHT, AREA_WIDTH } from \"./config\"\n\n// Resize Mars Canvas\nconst mars = document.getElementById(\"mars\") as HTMLCanvasElement\nmars.height = AREA_HEIGHT\nmars.width = AREA_WIDTH\n\n/**\n * Auto-generated code below aims at helping you parse\n * the standard input according to the problem statement.\n **/\n\nconst landerData = readline().split(\" \")\nconst lander = {\n  pos: {\n    x: parseInt(landerData[0]),\n    y: parseInt(landerData[1]),\n  },\n  fuel: parseInt(landerData[2]),\n}\n// const X = parseInt(MarsLander[0])\n// const Y = parseInt(MarsLander[1])\n// const fuel = parseInt(MarsLander[2])\n\nconst surfaceN = parseInt(readline()) // the number of points used to draw the surface of Mars.\nconst surfaces = [...Array(surfaceN).keys()].map((surface) => {\n  const coord = readline().split(\" \")\n  return {\n    x: parseInt(coord[0]),\n    y: parseInt(coord[1]),\n  }\n})\n\nconst game = new Game(AREA_HEIGHT, AREA_WIDTH)\ngame.init(surfaces, lander)\ngame.start()\n\n// TEST DE POSITION\nconst canvas = document.getElementById(\"mars\")\nfunction logPos(event) {\n  const rect = canvas?.getBoundingClientRect()\n  const x = ((event.clientX - rect!.x) * AREA_WIDTH) / rect!.width\n  const y =\n    (rect!.height + rect!.top - event.clientY) * (AREA_HEIGHT / rect!.height)\n  console.log(\"x\", x, \"y\", y)\n}\nfunction listenLogPos() {\n  canvas?.addEventListener(\"mousemove\", logPos)\n  canvas?.removeEventListener(\"mouseenter\", listenLogPos)\n}\nfunction posTester() {\n  canvas?.addEventListener(\"mouseenter\", listenLogPos)\n}\n// posTester()\n\n// for (let i = 0; i < surfaceN; i++) {\n//   var inputs = readline().split(\" \")\n//   const landX = parseInt(inputs[0]) // X coordinate of a surface point. (0 to 6999)\n//   const landY = parseInt(inputs[1]) // Y coordinate of a surface point. By linking all the points together in a sequential fashion, you form the surface of Mars.\n//   console.error(\"surface x y\", landX, landY)\n//   drawMars(inputs)\n// }\n\n// IDEES\n// - une surface d'attérissage est plate. Pour la trouver il faut chercher deux abcisses de même valeur consécutive\n\n// game loop\n// while (true) {\n//   var inputs = readline().split(\" \")\n//   const X = parseInt(inputs[0])\n//   const Y = parseInt(inputs[1])\n//   const hSpeed = parseInt(inputs[2]) // the horizontal speed (in m/s), can be negative.\n//   const vSpeed = parseInt(inputs[3]) // the vertical speed (in m/s), can be negative.\n//   const fuel = parseInt(inputs[4]) // the quantity of remaining fuel in liters.\n//   const rotate = parseInt(inputs[5]) // the rotation angle in degrees (-90 to 90).\n//   const power = parseInt(inputs[6]) // the thrust power (0 to 4).\n\n//   // Write an action using console.log()\n//   // To debug: console.error('Debug messages...');\n\n//   // rotate power. rotate is the desired rotation angle. power is the desired thrust power.\n//   console.log(\"-20 3\")\n// }\n\n// drawMarsLander({ x: X / SCALE_FACTOR, y: Y / SCALE_FACTOR })\n"],"names":["$a22a68cea04ec09e$var$reader","fichier","lignes","split","ligne","$a22a68cea04ec09e$var$fileReader","$parcel$interopDefault","$a22a68cea04ec09e$export$2e2bcd8739ae039","next","value","$4ddb142140a00a37$export$665647526a560662","surfaces","ctx","mars","document","getElementById","HTMLCanvasElement","Error","getContext","$4ddb142140a00a37$export$628c6d61845bd04a","save","translate","scale","beginPath","moveTo","lineTo","y","surface","x","fillStyle","fill","restore","$4ddb142140a00a37$export$87c5f5dfa31f2dfe","pos","rotation","$4ddb142140a00a37$export$33e53e6910baf874","fillRect","getBoundingClientRect","marsLander","Math","round","width","height","style","transform","$7b066675d1aa79fa$var$gameDataUlist","$7b066675d1aa79fa$var$gameDataTime","$7b066675d1aa79fa$var$gameDataAltitude","$7b066675d1aa79fa$var$gameDataPosition","$7b066675d1aa79fa$var$gameDataFuel","$7b066675d1aa79fa$var$gameDataHorizontalSpeed","$7b066675d1aa79fa$var$gameDataVerticalSpeed","$7b066675d1aa79fa$var$MarsLander","hSpeed","vSpeed","rotate","power","requestedPower","constructor","fuel","this","$b4e14b6b8da86996$var$mars","$b4e14b6b8da86996$var$landerData","$b4e14b6b8da86996$var$lander","parseInt","$b4e14b6b8da86996$var$surfaceN","$b4e14b6b8da86996$var$surfaces","Array","keys","map","coord","$b4e14b6b8da86996$var$game","gravity","timer","doTurn","bind","init","ground","lander","drawGround","draw","start","intersectSegment","A","B","I","P","D","E","denom","t","u","collision","tab","pointsNum","length","random","intersections","i","iseg","push","console","log","updateLander","setTimeout","window","requestAnimationFrame","updateDataUList","cos","PI","sin","toString","parseFloat","toFixed","JSON","stringify","textContent","playTurn"],"version":3,"file":"index.c26666a7.js.map"}